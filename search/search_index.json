{"config":{"lang":["en"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"PyFuseki \u00b6 pyfuseki - An easy way to mix together OWL and Jena Fuseki. A library that uses Python to connect and manipulate Jena Fuseki, which provides sync and async methods. By using pyfuseki, you can easily store data from your program into Jena Fuseki, following the ontology model, and then query and parse Jena. Documentation : https://yubincloud.github.io/pyfuseki/ Source Code : https://github.com/yubinCloud/pyfuseki Requirements \u00b6 Python 3.6+ PyFuseki stands on the shoulders of giants: Pydantic for the data parts. httpx for the network parts. rdflib for the RDF parts. Installation \u00b6 $ pip install pyfuseki ---> 100% Example \u00b6 First, we define the classes of the ontology predesigned: from pyfuseki.ontology_mapper import rdf_prefix , BaseRdfPrefixEnum from rdflib import Namespace from pyfuseki import config @rdf_prefix class RdfPrefix ( BaseRdfPrefixEnum ): BrandProject = Namespace ( config . COMMON_PREFIX + 'BrandProject' ) Firm = Namespace ( config . COMMON_PREFIX + 'Firm' ) Next, we define the data properties and object properties of the ontology predesigned: from pyfuseki.ontology_mapper import BaseProperty from rdflib import Namespace from pyfuseki import config yb = Namespace ( config . COMMON_PREFIX ) class ObjectProperty ( BaseProperty ): \"\"\" \u672c\u4f53\u4e2d\u6240\u6709Object properties\u7684\u679a\u4e3e name \u4e3a\u8be5 property \u7684 display name\uff0c value \u4e3a\u5305\u88c5\u4e86\u8be5 property IRI \u7684 URIRef \u5bf9\u8c61 \"\"\" brandAgencyObjectProperty = yb . brandAgencyObjectProperty subordinateTo = yb . subordinateTo # \u4ece\u5c5e\u4e8e class DataProperty ( BaseProperty ): \"\"\" \u672c\u4f53\u4e2d\u6240\u6709Data properties\u7684\u679a\u4e3e name \u4e3a\u8be5 property \u7684 display name\uff0c value \u4e3a\u5305\u88c5\u4e86\u8be5 property IRI \u7684 URIRef \u5bf9\u8c61 \"\"\" brandAgencyDataProperty = yb . brandAgencyDataProperty createTime = yb . createTime enName = yb . enName Finally, we can insert data which we collected into Jena Fuseki: async def insert_test (): pyfuseki . register . register_common_prefix ( \"http://www.yubin.com/kg/\" ) fuseki = AsyncFuseki ( 'http://localhost:3030' , 'pyfuseki_db' ) g = Graph () \"\"\"\u6d4b\u8bd5\u6574\u4e2a\u8fc7\u7a0b\"\"\" # RdfUtils.bind_prefixes_to_graph(self.g, [rp.BrandProject, rp.Firm]) # \u7ed1\u5b9a\u524d\u7f00 # \u5047\u8bbe\u83b7\u53d6\u7684\u6570\u636e\u4e3arev_data rev_data = { 'band_project' : '\u817e\u8baf' , '\u6240\u5c5e\u4f01\u4e1a' : '\u6df1\u5733\u5e02\u817e\u8baf\u8ba1\u7b97\u673a\u7cfb\u7edf\u6709\u9650\u516c\u53f8' , '\u6210\u7acb\u65e5\u671f' : '1998-11-11' , '\u82f1\u6587\u540d\u79f0' : 'QQ' } # \u5c06rev_data\u8f6c\u5316\u6210RDF\u4e09\u5143\u7ec4\u5e76\u52a0\u5165graph\u4e2d tencent = rp . BrandProject . val ( '\u817e\u8baf' ) RdfUtils . add_dict_to_graph ( g , tencent , { op . subordinateTo . value : rp . Firm . val ( '\u6df1\u5733\u5e02\u817e\u8baf\u8ba1\u7b97\u673a\u7cfb\u7edf\u6709\u9650\u516c\u53f8' ), dp . createTime . value : Literal ( rev_data [ '\u6210\u7acb\u65e5\u671f' ], datatype = XSD . date ), dp . enName . value : Literal ( rev_data [ '\u82f1\u6587\u540d\u79f0' ], datatype = XSD . string ) }) print ( g ) # \u5c06graph\u63d2\u5165 await fuseki . insert_graph ( g )","title":"Home"},{"location":"#pyfuseki","text":"pyfuseki - An easy way to mix together OWL and Jena Fuseki. A library that uses Python to connect and manipulate Jena Fuseki, which provides sync and async methods. By using pyfuseki, you can easily store data from your program into Jena Fuseki, following the ontology model, and then query and parse Jena. Documentation : https://yubincloud.github.io/pyfuseki/ Source Code : https://github.com/yubinCloud/pyfuseki","title":"PyFuseki"},{"location":"#requirements","text":"Python 3.6+ PyFuseki stands on the shoulders of giants: Pydantic for the data parts. httpx for the network parts. rdflib for the RDF parts.","title":"Requirements"},{"location":"#installation","text":"$ pip install pyfuseki ---> 100%","title":"Installation"},{"location":"#example","text":"First, we define the classes of the ontology predesigned: from pyfuseki.ontology_mapper import rdf_prefix , BaseRdfPrefixEnum from rdflib import Namespace from pyfuseki import config @rdf_prefix class RdfPrefix ( BaseRdfPrefixEnum ): BrandProject = Namespace ( config . COMMON_PREFIX + 'BrandProject' ) Firm = Namespace ( config . COMMON_PREFIX + 'Firm' ) Next, we define the data properties and object properties of the ontology predesigned: from pyfuseki.ontology_mapper import BaseProperty from rdflib import Namespace from pyfuseki import config yb = Namespace ( config . COMMON_PREFIX ) class ObjectProperty ( BaseProperty ): \"\"\" \u672c\u4f53\u4e2d\u6240\u6709Object properties\u7684\u679a\u4e3e name \u4e3a\u8be5 property \u7684 display name\uff0c value \u4e3a\u5305\u88c5\u4e86\u8be5 property IRI \u7684 URIRef \u5bf9\u8c61 \"\"\" brandAgencyObjectProperty = yb . brandAgencyObjectProperty subordinateTo = yb . subordinateTo # \u4ece\u5c5e\u4e8e class DataProperty ( BaseProperty ): \"\"\" \u672c\u4f53\u4e2d\u6240\u6709Data properties\u7684\u679a\u4e3e name \u4e3a\u8be5 property \u7684 display name\uff0c value \u4e3a\u5305\u88c5\u4e86\u8be5 property IRI \u7684 URIRef \u5bf9\u8c61 \"\"\" brandAgencyDataProperty = yb . brandAgencyDataProperty createTime = yb . createTime enName = yb . enName Finally, we can insert data which we collected into Jena Fuseki: async def insert_test (): pyfuseki . register . register_common_prefix ( \"http://www.yubin.com/kg/\" ) fuseki = AsyncFuseki ( 'http://localhost:3030' , 'pyfuseki_db' ) g = Graph () \"\"\"\u6d4b\u8bd5\u6574\u4e2a\u8fc7\u7a0b\"\"\" # RdfUtils.bind_prefixes_to_graph(self.g, [rp.BrandProject, rp.Firm]) # \u7ed1\u5b9a\u524d\u7f00 # \u5047\u8bbe\u83b7\u53d6\u7684\u6570\u636e\u4e3arev_data rev_data = { 'band_project' : '\u817e\u8baf' , '\u6240\u5c5e\u4f01\u4e1a' : '\u6df1\u5733\u5e02\u817e\u8baf\u8ba1\u7b97\u673a\u7cfb\u7edf\u6709\u9650\u516c\u53f8' , '\u6210\u7acb\u65e5\u671f' : '1998-11-11' , '\u82f1\u6587\u540d\u79f0' : 'QQ' } # \u5c06rev_data\u8f6c\u5316\u6210RDF\u4e09\u5143\u7ec4\u5e76\u52a0\u5165graph\u4e2d tencent = rp . BrandProject . val ( '\u817e\u8baf' ) RdfUtils . add_dict_to_graph ( g , tencent , { op . subordinateTo . value : rp . Firm . val ( '\u6df1\u5733\u5e02\u817e\u8baf\u8ba1\u7b97\u673a\u7cfb\u7edf\u6709\u9650\u516c\u53f8' ), dp . createTime . value : Literal ( rev_data [ '\u6210\u7acb\u65e5\u671f' ], datatype = XSD . date ), dp . enName . value : Literal ( rev_data [ '\u82f1\u6587\u540d\u79f0' ], datatype = XSD . string ) }) print ( g ) # \u5c06graph\u63d2\u5165 await fuseki . insert_graph ( g )","title":"Example"},{"location":"fuseki_connect/async_fuseki/","text":"An asynchronous query on Fuseki requires the use of Python's async / await syntax. This query is implemented with the help of the httpx open source library which can send requests asynchronously. 1. Initialize the instance \u00b6 from pyfuseki import AsyncFuseki async_fuseki = AsyncFuseki ( 'localhost:3030' , 'test_db' ) 2. Construct SPARQL statement \u00b6 sparql_str = \"\"\" SELECT * WHERE { ?s ?p ?o }; \"\"\" 3. Run the SPARQL statement \u00b6 Note that unlike synchronous, we need the await keyword to get the result of the query. The query result is of type AsyncFusekiResp which is a type that wraps the query response. query_result = await async_fuseki . query_sparql ( sparql_str ) 4. Call it with asyncio \u00b6 Because it is asynchronous, it cannot be run directly as a normal program. You need to wrap it with the async function and run it with asyncio . For example: from pyfuseki import AsyncFuseki import asyncio async def select_all (): async_fuseki = AsyncFuseki ( 'localhost:3030' , 'test_db' ) sparql_str = \"\"\" SELECT * WHERE { ?s ?p ?o }; \"\"\" return await async_fuseki . query_sparql ( sparql_str ) query_result = asyncio . run ( select_all ())","title":"async query"},{"location":"fuseki_connect/async_fuseki/#1-initialize-the-instance","text":"from pyfuseki import AsyncFuseki async_fuseki = AsyncFuseki ( 'localhost:3030' , 'test_db' )","title":"1. Initialize the instance"},{"location":"fuseki_connect/async_fuseki/#2-construct-sparql-statement","text":"sparql_str = \"\"\" SELECT * WHERE { ?s ?p ?o }; \"\"\"","title":"2. Construct SPARQL statement"},{"location":"fuseki_connect/async_fuseki/#3-run-the-sparql-statement","text":"Note that unlike synchronous, we need the await keyword to get the result of the query. The query result is of type AsyncFusekiResp which is a type that wraps the query response. query_result = await async_fuseki . query_sparql ( sparql_str )","title":"3. Run the SPARQL statement"},{"location":"fuseki_connect/async_fuseki/#4-call-it-with-asyncio","text":"Because it is asynchronous, it cannot be run directly as a normal program. You need to wrap it with the async function and run it with asyncio . For example: from pyfuseki import AsyncFuseki import asyncio async def select_all (): async_fuseki = AsyncFuseki ( 'localhost:3030' , 'test_db' ) sparql_str = \"\"\" SELECT * WHERE { ?s ?p ?o }; \"\"\" return await async_fuseki . query_sparql ( sparql_str ) query_result = asyncio . run ( select_all ())","title":"4. Call it with asyncio"},{"location":"fuseki_connect/first_step/","text":"Overview \u00b6 We provide two ways to connect Fuseki : sync and async. You can use one of the two ways depending on your program structure. For synchronous methods, we have FusekiQuery and FusekiUpdate for you to use. For asynchronous methods, we have AsyncFuseki for you to use. Notice, Asynchronous requires Python's async / await syntax. Initialize your instance \u00b6 Sync Fuseki \u00b6 It is a easy way for you to connect Fuseki, and it's easier to use our library. If you want to query data from Jena, you should use FusekiQuery . But if you want to insert RDF data into Jena, the FusekiUpdate may suit for you. They have the same form of parameters: fuseki_url and dataset_name . For example, if my Fuseki endpoint URL is localhost:3030 , and my dataset's name is test_db , I should initialize my Fuseki instance like this: from pyfuseki import FusekiUpdate , FusekiQuery fuseki_update = FusekiUpdate ( 'localhost:3030' , 'test_db' ) fuseki_query = FusekiQuery ( 'localhost:3030' , 'test_db' ) Async Fuseki \u00b6 If you want to use Fuseki as a coroutine way, AsyncFuseki will be a favorite. from pyfuseki import AsyncFuseki async_fuseki = AsyncFuseki ( 'localhost:3030' , 'test_db' )","title":"first step"},{"location":"fuseki_connect/first_step/#overview","text":"We provide two ways to connect Fuseki : sync and async. You can use one of the two ways depending on your program structure. For synchronous methods, we have FusekiQuery and FusekiUpdate for you to use. For asynchronous methods, we have AsyncFuseki for you to use. Notice, Asynchronous requires Python's async / await syntax.","title":"Overview"},{"location":"fuseki_connect/first_step/#initialize-your-instance","text":"","title":"Initialize your instance"},{"location":"fuseki_connect/first_step/#sync-fuseki","text":"It is a easy way for you to connect Fuseki, and it's easier to use our library. If you want to query data from Jena, you should use FusekiQuery . But if you want to insert RDF data into Jena, the FusekiUpdate may suit for you. They have the same form of parameters: fuseki_url and dataset_name . For example, if my Fuseki endpoint URL is localhost:3030 , and my dataset's name is test_db , I should initialize my Fuseki instance like this: from pyfuseki import FusekiUpdate , FusekiQuery fuseki_update = FusekiUpdate ( 'localhost:3030' , 'test_db' ) fuseki_query = FusekiQuery ( 'localhost:3030' , 'test_db' )","title":"Sync Fuseki"},{"location":"fuseki_connect/first_step/#async-fuseki","text":"If you want to use Fuseki as a coroutine way, AsyncFuseki will be a favorite. from pyfuseki import AsyncFuseki async_fuseki = AsyncFuseki ( 'localhost:3030' , 'test_db' )","title":"Async Fuseki"},{"location":"fuseki_connect/sync_query/","text":"Synchronously querying Fuseki can often be a performance bottleneck, so we prefer to use asynchronous querying. However, this approach to synchronization is often simpler. Therefore, we first try to use synchronous mode to connect Jena Fuseki and query the data. 1. Initialize the instance \u00b6 The method of initialization was introduced in the previous section. All we need here is an instance of FusekiQuery. from pyfuseki import FusekiQuery fuseki_query = FusekiQuery ( 'localhost:3030' , 'test_db' ) 2. Construct SPARQL statement \u00b6 Jena Fuseki supports SPARQL statements for direct queries, so we need to construct the appropriate query statements as needed. sparql_str = \"\"\" SELECT * WHERE { ?s ?p ?o }; \"\"\" 3. Run the SPARQL statement \u00b6 Our connection and query with Fuseki actually relied on another open source library: SPARQLWrapper . FusekiQuery actually acts as an proxy for this process. So, you can find that the type of query_result actually is SPARQLWrapper.Wrapper.QueryResult . If you want to parse this result, we also provide some useful tools for you. But if you want study it deeply, the document of SPARQLWrapper will be a good idea. query_result = fuseki_query . run_sparql ( sparql_str )","title":"sync query"},{"location":"fuseki_connect/sync_query/#1-initialize-the-instance","text":"The method of initialization was introduced in the previous section. All we need here is an instance of FusekiQuery. from pyfuseki import FusekiQuery fuseki_query = FusekiQuery ( 'localhost:3030' , 'test_db' )","title":"1. Initialize the instance"},{"location":"fuseki_connect/sync_query/#2-construct-sparql-statement","text":"Jena Fuseki supports SPARQL statements for direct queries, so we need to construct the appropriate query statements as needed. sparql_str = \"\"\" SELECT * WHERE { ?s ?p ?o }; \"\"\"","title":"2. Construct SPARQL statement"},{"location":"fuseki_connect/sync_query/#3-run-the-sparql-statement","text":"Our connection and query with Fuseki actually relied on another open source library: SPARQLWrapper . FusekiQuery actually acts as an proxy for this process. So, you can find that the type of query_result actually is SPARQLWrapper.Wrapper.QueryResult . If you want to parse this result, we also provide some useful tools for you. But if you want study it deeply, the document of SPARQLWrapper will be a good idea. query_result = fuseki_query . run_sparql ( sparql_str )","title":"3. Run the SPARQL statement"},{"location":"ontology_mapper/define_entities/","text":"Map your owl classes into Python \u00b6 Depending on your task requirements, you may already have an OWL ontology model. In order to use them in Python, you should create a mapping that enables a Python program to map to the ontology model. For the various entity classes, we call the ontology entity class RDF Prefix because we need to prefix it when we instantiate an object of that type. How to accomplish this mapping? It's very easy. All you need to do is define an enumeration class which derived from BaseRdfPrefixEnum and decorate it with rdf_prefix . Assuming that I have two types of \"brand project\" and \"company\" in my ontology model, I should do this: from pyfuseki.ontology_mapper import rdf_prefix , BaseRdfPrefixEnum from rdflib import Namespace from pyfuseki import config @rdf_prefix class RdfPrefix ( BaseRdfPrefixEnum ): BrandProject = Namespace ( config . COMMON_PREFIX + 'BrandProject' ) Firm = Namespace ( config . COMMON_PREFIX + 'Firm' ) Map your entity properties into Python \u00b6 Similar to class mapping in an ontology model, relationships need to be mapped. According to the OWL specification, we divide the relationship into Data Property and Object Property. You need to do the same as above, just inherit BaseProperty . For example: from pyfuseki.ontology_mapper import BaseProperty from rdflib import Namespace from pyfuseki import config kg = Namespace ( config . COMMON_PREFIX ) class ObjectProperty ( BaseProperty ): \"\"\" \u672c\u4f53\u4e2d\u6240\u6709Object properties\u7684\u679a\u4e3e name \u4e3a\u8be5 property \u7684 display name\uff0c value \u4e3a\u5305\u88c5\u4e86\u8be5 property IRI \u7684 URIRef \u5bf9\u8c61 \"\"\" subordinateTo = kg . subordinateTo # \u4ece\u5c5e\u4e8e class DataProperty ( BaseProperty ): \"\"\" \u672c\u4f53\u4e2d\u6240\u6709Data properties\u7684\u679a\u4e3e name \u4e3a\u8be5 property \u7684 display name\uff0c value \u4e3a\u5305\u88c5\u4e86\u8be5 property IRI \u7684 URIRef \u5bf9\u8c61 \"\"\" createTime = kg . createTime enName = kg . enName","title":"define your entity"},{"location":"ontology_mapper/define_entities/#map-your-owl-classes-into-python","text":"Depending on your task requirements, you may already have an OWL ontology model. In order to use them in Python, you should create a mapping that enables a Python program to map to the ontology model. For the various entity classes, we call the ontology entity class RDF Prefix because we need to prefix it when we instantiate an object of that type. How to accomplish this mapping? It's very easy. All you need to do is define an enumeration class which derived from BaseRdfPrefixEnum and decorate it with rdf_prefix . Assuming that I have two types of \"brand project\" and \"company\" in my ontology model, I should do this: from pyfuseki.ontology_mapper import rdf_prefix , BaseRdfPrefixEnum from rdflib import Namespace from pyfuseki import config @rdf_prefix class RdfPrefix ( BaseRdfPrefixEnum ): BrandProject = Namespace ( config . COMMON_PREFIX + 'BrandProject' ) Firm = Namespace ( config . COMMON_PREFIX + 'Firm' )","title":"Map your owl classes into Python"},{"location":"ontology_mapper/define_entities/#map-your-entity-properties-into-python","text":"Similar to class mapping in an ontology model, relationships need to be mapped. According to the OWL specification, we divide the relationship into Data Property and Object Property. You need to do the same as above, just inherit BaseProperty . For example: from pyfuseki.ontology_mapper import BaseProperty from rdflib import Namespace from pyfuseki import config kg = Namespace ( config . COMMON_PREFIX ) class ObjectProperty ( BaseProperty ): \"\"\" \u672c\u4f53\u4e2d\u6240\u6709Object properties\u7684\u679a\u4e3e name \u4e3a\u8be5 property \u7684 display name\uff0c value \u4e3a\u5305\u88c5\u4e86\u8be5 property IRI \u7684 URIRef \u5bf9\u8c61 \"\"\" subordinateTo = kg . subordinateTo # \u4ece\u5c5e\u4e8e class DataProperty ( BaseProperty ): \"\"\" \u672c\u4f53\u4e2d\u6240\u6709Data properties\u7684\u679a\u4e3e name \u4e3a\u8be5 property \u7684 display name\uff0c value \u4e3a\u5305\u88c5\u4e86\u8be5 property IRI \u7684 URIRef \u5bf9\u8c61 \"\"\" createTime = kg . createTime enName = kg . enName","title":"Map your entity properties into Python"},{"location":"ontology_mapper/insert_data/","text":"This section takes you step-by-step through converting the resulting data into RDF form and inserting it into Jena. Sync insert \u00b6 Step 1: Instantialize FusekiUpdate \u00b6 from pyfuseki import FusekiUpdate fuseki_update = FusekiUpdate ( 'localhost:3030' , 'test_db' ) Step 2: Prepare your data \u00b6 Suppose we have the following data to insert when curling \"Tencent\" : rev_data = { 'band_project' : '\u817e\u8baf' , '\u6240\u5c5e\u4f01\u4e1a' : '\u6df1\u5733\u5e02\u817e\u8baf\u8ba1\u7b97\u673a\u7cfb\u7edf\u6709\u9650\u516c\u53f8' , '\u6210\u7acb\u65e5\u671f' : '1998-11-11' , '\u82f1\u6587\u540d\u79f0' : 'QQ' } Step 3: Create a graph object \u00b6 When you call the interface to insert the data, you need to use the Graph object from the rdflib library and store the data you want to insert into it. So we need to import the rdflib library and create a 'Graph' object: from rdflib import Graph g = Graph () Step 4: Encapsulate data \u00b6 Each data needs to be encapsulated in the form of RDF triples, and each type corresponds to the type of OWL ontology in order to realize the deduction of Jena inference machine. The ontology mapper which be defined before will play an important role. Here we use already written mappings and encapsulate the data as triples. from pyfuseki.ontology_mapper import rdf_prefix , BaseRdfPrefixEnum from rdflib import Namespace from pyfuseki import config @rdf_prefix class RdfPrefix ( BaseRdfPrefixEnum ): BrandProject = Namespace ( config . COMMON_PREFIX + 'BrandProject' ) Firm = Namespace ( config . COMMON_PREFIX + 'Firm' ) from ... import RdfPrefix tencent = RdfPrefix . BrandProject . val ( '\u817e\u8baf' ) Here, we encapsulate the brand project \"Tencent\" into URIRef form, that is, 'Tencent' variable is a URIRef type object. By analogy with the above encapsulation method, we can encapsulate all previously owned data rev_data and put it into a encap_data_dict : from rdflib import Literal , XSD from ... import ObjectProperty as op from ... import DataProperty as dp encap_data_dict = { op . subordinateTo . value : FirmRdfPrefix . Firm . val ( '\u6df1\u5733\u5e02\u817e\u8baf\u8ba1\u7b97\u673a\u7cfb\u7edf\u6709\u9650\u516c\u53f8' ), dp . createTime . value : Literal ( rev_data [ '\u6210\u7acb\u65e5\u671f' ], datatype = XSD . date ), dp . enName . value : Literal ( rev_data [ '\u82f1\u6587\u540d\u79f0' ], datatype = XSD . string ) } Step 5: Insert data into graph \u00b6 With the data encapsulated above, we are ready to transfer it into graph . from pyfuseki import RdfUtils RdfUtils . add_dict_to_graph ( g , tencent , encap_data_dict ) In addition, you can use the add_list_to_graph function provided in RDFUtils or even the simpler g.add() method to insert data into the graph. # add_list_to_graph() method g = Graph () tencent = rp . BrandProject . val ( '\u817e\u8baf' ) spo_list = [ ( tencent , URIRef ( 'http://www.ifa.com#hasName' ), Literal ( '\u817e\u8baf' , datatype = XSD . string )), ( tencent , URIRef ( 'http://www.ifa.com#hasApp' ), URIRef ( 'http://www.ifa.com#App/wechat' )) ] add_list_to_graph ( g , spo_list ) # g.add() \u63d2\u5165\u65b9\u6848 g = Graph () tencent = rp . BrandProject . val ( '\u817e\u8baf' ) g . add (( tencent , URIRef ( 'http://www.ifa.com#hasName' ), Literal ( '\u817e\u8baf' , datatype = XSD . string ))) Select the most suitable data addition scheme according to the application scenario. Step 6: Insert graph into Jena \u00b6 After you've finished transferring the encapsulated data into graph , you can insert the data into Jena Fuseki using graph as a staging point: fusekiUpdate . insert_graph ( g ) View the results \u00b6 Open localhost:3030 in a browser and execute the following SPARQL statement on the corresponding dataset page to see the insert result: SELECT * WHERE { ?subject ?predicate ?object }; The insertion is successful if you can see the following result screen: The complete code \u00b6 from pyfuseki import FusekiUpdate import pyfuseki from pyfuseki.utils import RdfUtils from rdflib import Graph , Literal , XSD from demo.RdfPrefix import RdfPrefix as rp from demo.properties import ObjectProperty as op , DataProperty as dp pyfuseki . register . register_common_prefix ( \"http://www.yubin.com/kg/\" ) fuseki = FusekiUpdate ( 'http://localhost:3030' , 'pyfuseki_db' ) g = Graph () # RdfUtils.bind_prefixes_to_graph(self.g, [rp.BrandProject, rp.Firm]) # \u7ed1\u5b9a\u524d\u7f00 # \u5047\u8bbe\u83b7\u53d6\u7684\u6570\u636e\u4e3arev_data rev_data = { 'band_project' : '\u817e\u8baf' , '\u6240\u5c5e\u4f01\u4e1a' : '\u6df1\u5733\u5e02\u817e\u8baf\u8ba1\u7b97\u673a\u7cfb\u7edf\u6709\u9650\u516c\u53f8' , '\u6210\u7acb\u65e5\u671f' : '1998-11-11' , '\u82f1\u6587\u540d\u79f0' : 'QQ' } # \u5c06rev_data\u8f6c\u5316\u6210RDF\u4e09\u5143\u7ec4\u5e76\u52a0\u5165graph\u4e2d tencent = rp . BrandProject . val ( '\u817e\u8baf' ) RdfUtils . add_dict_to_graph ( g , tencent , { op . subordinateTo . value : rp . Firm . val ( '\u6df1\u5733\u5e02\u817e\u8baf\u8ba1\u7b97\u673a\u7cfb\u7edf\u6709\u9650\u516c\u53f8' ), dp . createTime . value : Literal ( rev_data [ '\u6210\u7acb\u65e5\u671f' ], datatype = XSD . date ), dp . enName . value : Literal ( rev_data [ '\u82f1\u6587\u540d\u79f0' ], datatype = XSD . string ) }) print ( g ) # \u5c06graph\u63d2\u5165 fuseki . insert_graph ( g ) Async insert \u00b6 The overall process is similar to that of synchronous mode. All you need to do is replace FusekiUpdate with AsyncFuseki . from pyfuseki import AsyncFuseki import pyfuseki from pyfuseki.utils import RdfUtils from rdflib import Graph , Literal , XSD from demo.RdfPrefix import RdfPrefix as rp from demo.properties import ObjectProperty as op , DataProperty as dp import asyncio async def insert_test (): pyfuseki . register . register_common_prefix ( \"http://www.yubin.com/kg/\" ) fuseki = AsyncFuseki ( 'http://localhost:3030' , 'pyfuseki_db' ) g = Graph () # RdfUtils.bind_prefixes_to_graph(self.g, [rp.BrandProject, rp.Firm]) # \u7ed1\u5b9a\u524d\u7f00 # \u5047\u8bbe\u83b7\u53d6\u7684\u6570\u636e\u4e3arev_data rev_data = { 'band_project' : '\u817e\u8baf' , '\u6240\u5c5e\u4f01\u4e1a' : '\u6df1\u5733\u5e02\u817e\u8baf\u8ba1\u7b97\u673a\u7cfb\u7edf\u6709\u9650\u516c\u53f8' , '\u6210\u7acb\u65e5\u671f' : '1998-11-11' , '\u82f1\u6587\u540d\u79f0' : 'QQ' } # \u5c06rev_data\u8f6c\u5316\u6210RDF\u4e09\u5143\u7ec4\u5e76\u52a0\u5165graph\u4e2d tencent = rp . BrandProject . val ( '\u817e\u8baf' ) RdfUtils . add_dict_to_graph ( g , tencent , { op . subordinateTo . value : rp . Firm . val ( '\u6df1\u5733\u5e02\u817e\u8baf\u8ba1\u7b97\u673a\u7cfb\u7edf\u6709\u9650\u516c\u53f8' ), dp . createTime . value : Literal ( rev_data [ '\u6210\u7acb\u65e5\u671f' ], datatype = XSD . date ), dp . enName . value : Literal ( rev_data [ '\u82f1\u6587\u540d\u79f0' ], datatype = XSD . string ) }) print ( g ) # \u5c06graph\u63d2\u5165 await fuseki . insert_graph ( g ) if __name__ == '__main__' : asyncio . run ( insert_test ())","title":"insert RDF data into Jena"},{"location":"ontology_mapper/insert_data/#sync-insert","text":"","title":"Sync insert"},{"location":"ontology_mapper/insert_data/#step-1-instantialize-fusekiupdate","text":"from pyfuseki import FusekiUpdate fuseki_update = FusekiUpdate ( 'localhost:3030' , 'test_db' )","title":"Step 1: Instantialize FusekiUpdate"},{"location":"ontology_mapper/insert_data/#step-2-prepare-your-data","text":"Suppose we have the following data to insert when curling \"Tencent\" : rev_data = { 'band_project' : '\u817e\u8baf' , '\u6240\u5c5e\u4f01\u4e1a' : '\u6df1\u5733\u5e02\u817e\u8baf\u8ba1\u7b97\u673a\u7cfb\u7edf\u6709\u9650\u516c\u53f8' , '\u6210\u7acb\u65e5\u671f' : '1998-11-11' , '\u82f1\u6587\u540d\u79f0' : 'QQ' }","title":"Step 2: Prepare your data"},{"location":"ontology_mapper/insert_data/#step-3-create-a-graph-object","text":"When you call the interface to insert the data, you need to use the Graph object from the rdflib library and store the data you want to insert into it. So we need to import the rdflib library and create a 'Graph' object: from rdflib import Graph g = Graph ()","title":"Step 3: Create a graph object"},{"location":"ontology_mapper/insert_data/#step-4-encapsulate-data","text":"Each data needs to be encapsulated in the form of RDF triples, and each type corresponds to the type of OWL ontology in order to realize the deduction of Jena inference machine. The ontology mapper which be defined before will play an important role. Here we use already written mappings and encapsulate the data as triples. from pyfuseki.ontology_mapper import rdf_prefix , BaseRdfPrefixEnum from rdflib import Namespace from pyfuseki import config @rdf_prefix class RdfPrefix ( BaseRdfPrefixEnum ): BrandProject = Namespace ( config . COMMON_PREFIX + 'BrandProject' ) Firm = Namespace ( config . COMMON_PREFIX + 'Firm' ) from ... import RdfPrefix tencent = RdfPrefix . BrandProject . val ( '\u817e\u8baf' ) Here, we encapsulate the brand project \"Tencent\" into URIRef form, that is, 'Tencent' variable is a URIRef type object. By analogy with the above encapsulation method, we can encapsulate all previously owned data rev_data and put it into a encap_data_dict : from rdflib import Literal , XSD from ... import ObjectProperty as op from ... import DataProperty as dp encap_data_dict = { op . subordinateTo . value : FirmRdfPrefix . Firm . val ( '\u6df1\u5733\u5e02\u817e\u8baf\u8ba1\u7b97\u673a\u7cfb\u7edf\u6709\u9650\u516c\u53f8' ), dp . createTime . value : Literal ( rev_data [ '\u6210\u7acb\u65e5\u671f' ], datatype = XSD . date ), dp . enName . value : Literal ( rev_data [ '\u82f1\u6587\u540d\u79f0' ], datatype = XSD . string ) }","title":"Step 4: Encapsulate data"},{"location":"ontology_mapper/insert_data/#step-5-insert-data-into-graph","text":"With the data encapsulated above, we are ready to transfer it into graph . from pyfuseki import RdfUtils RdfUtils . add_dict_to_graph ( g , tencent , encap_data_dict ) In addition, you can use the add_list_to_graph function provided in RDFUtils or even the simpler g.add() method to insert data into the graph. # add_list_to_graph() method g = Graph () tencent = rp . BrandProject . val ( '\u817e\u8baf' ) spo_list = [ ( tencent , URIRef ( 'http://www.ifa.com#hasName' ), Literal ( '\u817e\u8baf' , datatype = XSD . string )), ( tencent , URIRef ( 'http://www.ifa.com#hasApp' ), URIRef ( 'http://www.ifa.com#App/wechat' )) ] add_list_to_graph ( g , spo_list ) # g.add() \u63d2\u5165\u65b9\u6848 g = Graph () tencent = rp . BrandProject . val ( '\u817e\u8baf' ) g . add (( tencent , URIRef ( 'http://www.ifa.com#hasName' ), Literal ( '\u817e\u8baf' , datatype = XSD . string ))) Select the most suitable data addition scheme according to the application scenario.","title":"Step 5: Insert data into graph"},{"location":"ontology_mapper/insert_data/#step-6-insert-graph-into-jena","text":"After you've finished transferring the encapsulated data into graph , you can insert the data into Jena Fuseki using graph as a staging point: fusekiUpdate . insert_graph ( g )","title":"Step 6: Insert graph into Jena"},{"location":"ontology_mapper/insert_data/#view-the-results","text":"Open localhost:3030 in a browser and execute the following SPARQL statement on the corresponding dataset page to see the insert result: SELECT * WHERE { ?subject ?predicate ?object }; The insertion is successful if you can see the following result screen:","title":"View the results"},{"location":"ontology_mapper/insert_data/#the-complete-code","text":"from pyfuseki import FusekiUpdate import pyfuseki from pyfuseki.utils import RdfUtils from rdflib import Graph , Literal , XSD from demo.RdfPrefix import RdfPrefix as rp from demo.properties import ObjectProperty as op , DataProperty as dp pyfuseki . register . register_common_prefix ( \"http://www.yubin.com/kg/\" ) fuseki = FusekiUpdate ( 'http://localhost:3030' , 'pyfuseki_db' ) g = Graph () # RdfUtils.bind_prefixes_to_graph(self.g, [rp.BrandProject, rp.Firm]) # \u7ed1\u5b9a\u524d\u7f00 # \u5047\u8bbe\u83b7\u53d6\u7684\u6570\u636e\u4e3arev_data rev_data = { 'band_project' : '\u817e\u8baf' , '\u6240\u5c5e\u4f01\u4e1a' : '\u6df1\u5733\u5e02\u817e\u8baf\u8ba1\u7b97\u673a\u7cfb\u7edf\u6709\u9650\u516c\u53f8' , '\u6210\u7acb\u65e5\u671f' : '1998-11-11' , '\u82f1\u6587\u540d\u79f0' : 'QQ' } # \u5c06rev_data\u8f6c\u5316\u6210RDF\u4e09\u5143\u7ec4\u5e76\u52a0\u5165graph\u4e2d tencent = rp . BrandProject . val ( '\u817e\u8baf' ) RdfUtils . add_dict_to_graph ( g , tencent , { op . subordinateTo . value : rp . Firm . val ( '\u6df1\u5733\u5e02\u817e\u8baf\u8ba1\u7b97\u673a\u7cfb\u7edf\u6709\u9650\u516c\u53f8' ), dp . createTime . value : Literal ( rev_data [ '\u6210\u7acb\u65e5\u671f' ], datatype = XSD . date ), dp . enName . value : Literal ( rev_data [ '\u82f1\u6587\u540d\u79f0' ], datatype = XSD . string ) }) print ( g ) # \u5c06graph\u63d2\u5165 fuseki . insert_graph ( g )","title":"The complete code"},{"location":"ontology_mapper/insert_data/#async-insert","text":"The overall process is similar to that of synchronous mode. All you need to do is replace FusekiUpdate with AsyncFuseki . from pyfuseki import AsyncFuseki import pyfuseki from pyfuseki.utils import RdfUtils from rdflib import Graph , Literal , XSD from demo.RdfPrefix import RdfPrefix as rp from demo.properties import ObjectProperty as op , DataProperty as dp import asyncio async def insert_test (): pyfuseki . register . register_common_prefix ( \"http://www.yubin.com/kg/\" ) fuseki = AsyncFuseki ( 'http://localhost:3030' , 'pyfuseki_db' ) g = Graph () # RdfUtils.bind_prefixes_to_graph(self.g, [rp.BrandProject, rp.Firm]) # \u7ed1\u5b9a\u524d\u7f00 # \u5047\u8bbe\u83b7\u53d6\u7684\u6570\u636e\u4e3arev_data rev_data = { 'band_project' : '\u817e\u8baf' , '\u6240\u5c5e\u4f01\u4e1a' : '\u6df1\u5733\u5e02\u817e\u8baf\u8ba1\u7b97\u673a\u7cfb\u7edf\u6709\u9650\u516c\u53f8' , '\u6210\u7acb\u65e5\u671f' : '1998-11-11' , '\u82f1\u6587\u540d\u79f0' : 'QQ' } # \u5c06rev_data\u8f6c\u5316\u6210RDF\u4e09\u5143\u7ec4\u5e76\u52a0\u5165graph\u4e2d tencent = rp . BrandProject . val ( '\u817e\u8baf' ) RdfUtils . add_dict_to_graph ( g , tencent , { op . subordinateTo . value : rp . Firm . val ( '\u6df1\u5733\u5e02\u817e\u8baf\u8ba1\u7b97\u673a\u7cfb\u7edf\u6709\u9650\u516c\u53f8' ), dp . createTime . value : Literal ( rev_data [ '\u6210\u7acb\u65e5\u671f' ], datatype = XSD . date ), dp . enName . value : Literal ( rev_data [ '\u82f1\u6587\u540d\u79f0' ], datatype = XSD . string ) }) print ( g ) # \u5c06graph\u63d2\u5165 await fuseki . insert_graph ( g ) if __name__ == '__main__' : asyncio . run ( insert_test ())","title":"Async insert"}]}